src = [2, 2, 2, 7, 23, 1, 44, 44, 3, 2, 10, 7, 4, 11]
# result = [23, 1, 3, 10, 4, 11]
# Способ "решения в лоб". Прост и понятен, но за счет многократного выполнения подсчета
# на повторяющихся элементах - не очень эффективен.

print([n for n in src if src.count(n) == 1])

# Можно ограничить количество подсчетов, превратив список в словарь, что исключит проблему предыдущего решения,
# так как ключи словаря уникальны. Получаем кортеж с помощью enumerate, используя генератор создаем словарь,
# меняя id элемента и его значение местами. Словари - это неупорядоченные коллекции элементов,
# но в нашем случае это не важно, ведь каждый шаг итерации будет приводить нас к ключу в соответствии с порядком
# первого вхождения элемента в список src, порядок следования элементов будет сохранен.
# 2: 9
# 7: 11,
# 23: 4,
# 1: 5,
# 44: 7,
# 3: 8,
# 10: 10,
# 4: 12,
# 11: 13

print([n for n in dict((j, i) for i, j in enumerate(src)) if src.count(n) == 1])

# Можно решить задачу через создание множества (все элементы множества уникальны), проверить каждый элемент множества
# на количество вхождений в список src, если выполняется условие, что вхождение только одно,
# создаем кортеж из двух элементов, первый элемент - это индекс первого вхождения искомого элемента в список src,
# а второй - значение самого элемента. Помещаем их в список, после сортировки списка
# (список будет отсортирован по индексу первого вхождения) мы получим правильную очередность элементов,
# остается забрать каждый второй элемент каждого кортежа и представить результат в виде списка.

print(list(num[1] for num in sorted([(src.index(n), n) for n in set(src) if src.count(n) == 1])))
